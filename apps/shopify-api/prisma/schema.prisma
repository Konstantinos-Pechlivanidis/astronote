generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Shop {
  id                    String                 @id @default(cuid())
  shopDomain            String                 @unique
  shopName              String?
  accessToken           String?
  status                String                 @default("active")
  country               String?
  currency              String                 @default("EUR")
  credits               Int                    @default(0)
  eshopType             EshopType?             // eShop vertical/category (fashion, beauty, electronics, etc.)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  automations           UserAutomation[]
  automationLogs        AutomationLog[]
  campaigns             Campaign[]
  contacts              Contact[]
  discounts             DiscountLink[]
  messages              MessageLog[]
  segments              Segment[]
  templates             Template[] // Templates owned by this shop (tenant-scoped)
  templateUsage         TemplateUsage[] // Usage tracking (renamed for clarity)
  wallet                Wallet?
  transactions          WalletTransaction[]
  creditTransactions    CreditTransaction[]
  creditReservations    CreditReservation[]
  billingTransactions   BillingTransaction[]
  purchases             Purchase[]
  settings              ShopSettings?
  eventProcessingStates EventProcessingState[]
  abandonedCheckouts    AbandonedCheckout[]
  scheduledAutomations  ScheduledAutomation[]
  automationSequences   AutomationSequence[]
  shortLinks            ShortLink[]
  webhookEvents         WebhookEvent[]
  enqueueRequests       EnqueueRequest[]
  billingProfile        ShopBillingProfile?
  subscriptionRecord    Subscription?
  invoiceRecords        InvoiceRecord[]
  taxEvidenceRecords    TaxEvidence[]

  // Subscription fields
  stripeCustomerId           String?               @unique @db.VarChar(255)
  stripeSubscriptionId       String?               @unique @db.VarChar(255)
  planType                   SubscriptionPlanType?
  subscriptionStatus         SubscriptionStatus    @default(inactive)
  lastFreeCreditsAllocatedAt DateTime?
  lastBillingError           String?               @db.VarChar(255)
  // Subscription interval and billing period tracking
  subscriptionInterval       String?              // 'month' | 'year'
  currentPeriodStart         DateTime?            // Billing period start date
  currentPeriodEnd           DateTime?            // Billing period end date
  cancelAtPeriodEnd          Boolean              @default(false) // Whether subscription will cancel at period end
  // Allowance tracking (free SMS per billing period)
  includedSmsPerPeriod       Int?                // 100 for monthly, 500 for yearly
  usedSmsThisPeriod          Int                  @default(0) // SMS sent this billing period
  lastPeriodResetAt          DateTime?            // When allowance was last reset

  @@index([status, createdAt])
  @@index([country])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([subscriptionStatus])
  @@index([eshopType]) // Index for eShop type filtering
}

model Contact {
  id                 String              @id @default(cuid())
  shopId             String
  firstName          String?
  lastName           String?
  phoneE164          String
  email              String?
  gender             String? // "male", "female", "other", or null
  birthDate          DateTime? // Required for birthday automations (aligned with Retail: birthday)
  tags               String[]            @default([])
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  smsConsent         SmsConsent          @default(unknown) // Enum for backward compatibility
  smsConsentStatus   String?             @db.VarChar(40) // String field aligned with Retail ("opted_in", "opted_out", null)
  smsConsentAt       DateTime? // When consent was given/revoked
  smsConsentSource   String?             @db.VarChar(80) // Source of consent (e.g., "manual", "import", "unsubscribe_link")
  isSubscribed       Boolean             @default(true) // Subscription state (aligned with Retail)
  unsubscribeTokenHash String?           @db.VarChar(64) // Hash for secure unsubscribe links (aligned with Retail)
  unsubscribedAt     DateTime? // When contact unsubscribed
  hasPurchased       Boolean             @default(false) // Track if contact has made a purchase
  firstPurchaseAt    DateTime? // Date of first purchase
  lastOrderAt        DateTime? // Date of last order (for win-back automation)
  recipients         CampaignRecipient[]
  clickEvents        ClickEvent[]
  shop               Shop                @relation(fields: [shopId], references: [id], onDelete: Cascade)
  memberships        SegmentMembership[]
  abandonedCheckouts AbandonedCheckout[]
  shortLinks         ShortLink[]

  @@unique([shopId, phoneE164])
  @@unique([shopId, email])
  @@index([shopId, phoneE164])
  @@index([shopId, email])
  @@index([shopId, smsConsent])
  @@index([shopId, smsConsentStatus]) // Index for consent status filtering
  @@index([shopId, birthDate])
  @@index([shopId, createdAt])
  @@index([shopId, gender])
  @@index([shopId, isSubscribed]) // Index for subscription filtering (aligned with Retail)
  @@index([shopId, hasPurchased])
  @@index([shopId, lastOrderAt])
  @@index([unsubscribeTokenHash]) // Index for unsubscribe token lookup (aligned with Retail)
}

model Segment {
  id          String              @id @default(cuid())
  shopId      String
  name        String
  key         String?             // unique per shop (e.g. "gender_male", "age_18_24") for system segments
  type        String              @default("custom") // "system" | "custom"
  ruleJson    Json                // Renamed from ruleJson for consistency, but keeping for backward compat
  criteriaJson Json?               // New field for structured criteria (preferred)
  isActive    Boolean             @default(true)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  shop        Shop                @relation(fields: [shopId], references: [id], onDelete: Cascade)
  memberships SegmentMembership[]

  @@unique([shopId, name])
  @@unique([shopId, key])         // Unique constraint for system segments by key
  @@index([shopId, name])
  @@index([shopId, key])
  @@index([shopId, type])
  @@index([shopId, createdAt])
}

model SegmentMembership {
  id        String  @id @default(cuid())
  segmentId String
  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  segment   Segment @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  @@unique([segmentId, contactId])
}

model Campaign {
  id                 String              @id @default(cuid())
  shopId             String
  name               String
  message            String
  audience           String
  discountId         String?
  scheduleAt         DateTime?
  recurringDays      Int?
  meta               Json?               // Store additional data (discountValue, includeDiscount, etc.)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  scheduleType       ScheduleType
  status             CampaignStatus      @default(draft)
  priority           CampaignPriority    @default(normal)
  startedAt          DateTime?           // When campaign started sending (aligned with Retail)
  finishedAt         DateTime?           // When campaign finished (aligned with Retail)
  shop               Shop                @relation(fields: [shopId], references: [id], onDelete: Cascade)
  metrics            CampaignMetrics?
  recipients         CampaignRecipient[]
  messages           MessageLog[]
  creditTransactions CreditTransaction[]
  creditReservations CreditReservation[]
  ClickEvent         ClickEvent[]
  shortLinks         ShortLink[]

  @@unique([shopId, name])
  @@index([shopId, status])
  @@index([shopId, createdAt])
  @@index([shopId, scheduleAt])
  @@index([priority])
}

model CampaignRecipient {
  id             String       @id @default(cuid())
  campaignId     String
  contactId      String?
  phoneE164      String
  status         String
  mittoMessageId String?
  bulkId         String? // Mitto bulkId for batch tracking (bulk SMS)
  retryCount     Int          @default(0) // Track retry attempts for idempotency
  sentAt         DateTime?
  deliveredAt    DateTime?
  failedAt       DateTime?   // When message failed (aligned with Retail)
  error          String?
  deliveryStatus String? // Mitto delivery status: Delivered, Failed, Queued, etc.
  senderNumber   String? // Sender number used for this message
  campaign       Campaign     @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  contact        Contact?     @relation(fields: [contactId], references: [id])
  clickEvents    ClickEvent[]

  @@unique([campaignId, phoneE164]) // Prevent duplicate messages to same phone in same campaign
  @@index([campaignId, status]) // For filtering by campaign and status
  @@index([campaignId, phoneE164]) // For quick lookups during SMS sending
  @@index([sentAt]) // For time-based queries
  @@index([status]) // For status-based filtering
  @@index([bulkId]) // For batch-level queries (bulk SMS)
  @@index([mittoMessageId]) // For DLR webhook lookups
}

model CampaignMetrics {
  id             String   @id @default(cuid())
  campaignId     String   @unique
  totalSent      Int      @default(0) // Actually sent (status='sent') - Phase 2.2
  totalDelivered Int      @default(0)
  totalFailed    Int      @default(0)
  totalProcessed Int      @default(0) // Processed = sent + failed (Phase 2.2)
  totalClicked   Int      @default(0)
  campaign       Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
}

model ClickEvent {
  id          String             @id @default(cuid())
  campaignId  String
  recipientId String? // Optional: link to CampaignRecipient
  contactId   String? // Optional: link to Contact
  phoneE164   String // Phone number that clicked
  linkType    String             @default("unsubscribe") // unsubscribe, discount, etc.
  clickedAt   DateTime           @default(now())
  ipAddress   String? // Optional: IP address for analytics
  userAgent   String? // Optional: User agent for analytics
  campaign    Campaign           @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  recipient   CampaignRecipient? @relation(fields: [recipientId], references: [id], onDelete: SetNull)
  contact     Contact?           @relation(fields: [contactId], references: [id], onDelete: SetNull)

  @@unique([campaignId, recipientId, linkType]) // Prevent duplicate clicks for same campaign+recipient+linkType
  @@index([campaignId])
  @@index([recipientId])
  @@index([contactId])
  @@index([phoneE164])
  @@index([clickedAt])
  @@index([campaignId, clickedAt])
}

model MessageLog {
  id                 String              @id @default(cuid())
  shopId             String
  phoneE164          String
  provider           String
  providerMsgId      String?
  payload            Json?
  error              String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  campaignId         String?
  direction          MessageDirection
  status             MessageStatus?
  deliveryStatus     String? // Mitto delivery status
  senderNumber       String? // Sender number used
  campaign           Campaign?           @relation(fields: [campaignId], references: [id])
  shop               Shop                @relation(fields: [shopId], references: [id], onDelete: Cascade)
  creditTransactions CreditTransaction[]

  @@index([shopId, direction])
  @@index([shopId, status])
  @@index([shopId, createdAt])
  @@index([shopId, providerMsgId])
  @@index([shopId, phoneE164])
  @@index([campaignId, status]) // For campaign status queries
  @@index([createdAt, status]) // For time-based filtering with status
  @@index([providerMsgId]) // For quick lookups by provider message ID
}

model Wallet {
  id                 String              @id @default(cuid())
  shopId             String              @unique
  balance            Int                 @default(0)
  totalUsed          Int                 @default(0)
  totalBought        Int                 @default(0)
  active             Boolean             @default(true)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  shop               Shop                @relation(fields: [shopId], references: [id], onDelete: Cascade)
  creditTransactions CreditTransaction[]
}

model SmsPackage {
  id          String   @id @default(cuid())
  name        String
  credits     Int
  priceCents  Int
  currency    String   @default("EUR")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  description String?
  features    String[] @default([])
  isActive    Boolean  @default(true)
  isPopular   Boolean  @default(false)
}

model Package {
  id         String     @id @default(cuid())
  name       String     @unique
  units      Int // credits included
  priceCents Int // price in cents (EUR, for reference)
  priceCentsUsd Int? // price in cents (USD, optional)
  active     Boolean    @default(true)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  Purchase   Purchase[]

  // Stripe price IDs (optional, can be set via env or admin)
  stripePriceIdEur String? @db.VarChar(255)
  stripePriceIdUsd String? @db.VarChar(255)

  @@index([stripePriceIdEur])
  @@index([stripePriceIdUsd])
}

model Purchase {
  id         String        @id @default(cuid())
  shopId     String
  packageId  String
  package    Package       @relation(fields: [packageId], references: [id], onDelete: Restrict)
  units      Int
  priceCents Int
  status     PaymentStatus @default(pending)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  // Stripe integration
  stripeSessionId       String? @unique
  stripePaymentIntentId String?
  stripeCustomerId      String?
  stripePriceId         String?
  currency              String? @db.VarChar(3)
  idempotencyKey        String? @db.VarChar(128) // For idempotent purchase requests

  shop Shop @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([shopId])
  @@index([packageId])
  @@index([stripeSessionId])
  @@index([status])
  @@index([shopId, status])
  @@unique([shopId, idempotencyKey]) // Ensure idempotency per shop
}

model WalletTransaction {
  id        String          @id @default(cuid())
  shopId    String
  credits   Int
  ref       String?
  meta      Json?
  createdAt DateTime        @default(now())
  type      TransactionType
  shop      Shop            @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

model TemplateUsage {
  id         String    @id @default(cuid())
  shopId     String
  templateId String
  usedCount  Int       @default(0)
  lastUsedAt DateTime?
  shop       Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)
  template   Template  @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@unique([shopId, templateId]) // One usage record per shop + template
  @@index([shopId]) // For querying usage by shop
  @@index([templateId]) // For querying usage by template
}

model Automation {
  id              String            @id @default(cuid())
  title           String
  description     String?
  triggerEvent    AutomationTrigger
  defaultMessage  String
  isSystemDefault Boolean           @default(false)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  userAutomations UserAutomation[]
}

model UserAutomation {
  id           String     @id @default(cuid())
  shopId       String
  automationId String
  userMessage  String? // Custom message by user
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  shop         Shop       @relation(fields: [shopId], references: [id], onDelete: Cascade)
  automation   Automation @relation(fields: [automationId], references: [id], onDelete: Cascade)

  @@unique([shopId, automationId])
}

model AutomationLog {
  id           String   @id @default(cuid())
  automationId String
  shopId       String
  status       String // 'sent', 'skipped', 'failed'
  reason       String? // Reason for skip/failure
  triggeredAt  DateTime @default(now())
  createdAt    DateTime @default(now())
  shop         Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([shopId, status])
  @@index([automationId, triggeredAt])
}

model AbandonedCheckout {
  id                   String    @id @default(cuid())
  shopId               String
  contactId            String
  checkoutId           String // Shopify checkout ID
  lineItems            Json // Store line items as JSON
  subtotalPrice        String? // Subtotal price
  currency             String? // Currency code
  abandonedCheckoutUrl String? // Recovery URL
  abandonedAt          DateTime  @default(now())
  recoveredAt          DateTime? // When order was completed
  scheduledJobIds      String[]  @default([]) // Array of Bull job IDs for cancellation
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  shop                 Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)
  contact              Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([shopId, checkoutId])
  @@index([shopId, contactId])
  @@index([shopId, abandonedAt])
  @@index([shopId, recoveredAt])
  @@index([contactId])
}

model ScheduledAutomation {
  id             String    @id @default(cuid())
  shopId         String
  contactId      String
  automationId   String? // Optional: link to Automation
  automationType String // Automation trigger type
  jobId          String    @unique // Bull queue job ID - must be unique to prevent duplicates
  scheduledFor   DateTime // When the automation should execute
  status         String    @default("scheduled") // scheduled, cancelled, executed, failed
  orderId        String? // Optional: link to order for cancellation
  checkoutId     String? // Optional: link to checkout for cancellation
  data           Json? // Additional automation data
  executedAt     DateTime?
  cancelledAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  shop           Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([shopId, automationType])
  @@index([shopId, status])
  @@index([shopId, scheduledFor])
  @@index([contactId])
  @@index([orderId])
  @@index([checkoutId])
}

model AutomationSequence {
  id            String    @id @default(cuid())
  shopId        String
  contactId     String
  sequenceType  String // 'welcome', 'post_purchase', 'win_back'
  currentStep   Int       @default(1) // Current step in sequence (1, 2, 3, etc.)
  totalSteps    Int // Total steps in sequence
  status        String    @default("active") // active, completed, cancelled
  startedAt     DateTime  @default(now())
  completedAt   DateTime?
  cancelledAt   DateTime?
  scheduledJobs String[]  @default([]) // Array of Bull job IDs
  metadata      Json? // Additional sequence data
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  shop          Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([shopId, contactId, sequenceType]) // Prevent duplicate sequences for same contact
  @@index([shopId, status])
  @@index([contactId])
}

model EventProcessingState {
  id              String   @id @default(cuid())
  shopId          String
  automationType  String // 'welcome', 'order_placed', 'order_fulfilled'
  lastEventId     String? // Last processed Shopify event GID
  lastProcessedAt DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  shop            Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([shopId, automationType])
  @@index([shopId, automationType])
}

model DiscountLink {
  id         String   @id @default(cuid())
  shopId     String
  code       String
  campaignId String?
  createdAt  DateTime @default(now())
  shop       Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([shopId, code])
}

enum SmsConsent {
  opted_in
  opted_out
  unknown
}

enum CampaignStatus {
  draft
  scheduled
  sending
  paused      // Aligned with Retail: allows pausing and resuming campaigns
  completed   // Aligned with Retail: campaign finished successfully
  sent        // Legacy alias for completed (kept for backward compatibility)
  failed
  cancelled   // Shopify-specific: user cancelled campaign
}

enum CampaignPriority {
  low
  normal
  high
  urgent
}

enum ScheduleType {
  immediate
  scheduled
  recurring
}

enum MessageDirection {
  outbound
  inbound
}

enum MessageStatus {
  queued
  sent
  delivered
  failed
  received
}

enum TransactionType {
  purchase
  debit
  credit
  refund
  adjustment
}

enum SubscriptionPlanType {
  starter
  pro
}

enum SubscriptionStatus {
  active
  trialing
  past_due
  unpaid
  incomplete
  paused
  inactive
  cancelled
}

enum EshopType {
  fashion
  beauty
  electronics
  food
  services
  home
  sports
  books
  toys
  generic
}

enum CreditTxnType {
  credit // e.g. admin topup, purchase, subscription credits
  debit // e.g. campaign enqueue
  refund // e.g. immediate provider hard-fail, stripe refund
}

enum AutomationTrigger {
  welcome
  abandoned_cart
  order_confirmation
  shipping_update
  delivery_confirmation
  review_request
  reorder_reminder
  birthday
  customer_inactive
  cart_abandoned
  order_placed
  order_fulfilled
  cross_sell
  upsell
}

enum PaymentStatus {
  pending
  paid
  failed
  refunded
}

model ShopSettings {
  id           String   @id @default(cuid())
  shopId       String   @unique
  senderNumber String? // Custom sender number for SMS
  senderName   String? // Custom sender name
  timezone     String   @default("UTC")
  currency     String   @default("EUR")
  baseUrl      String?  // Per-tenant base URL override for dynamic URL generation
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  shop         Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

model ShopBillingProfile {
  id             String   @id @default(cuid())
  shopId         String   @unique
  legalName      String?
  vatNumber      String?  @db.VarChar(32)
  vatCountry     String?  @db.VarChar(2)
  billingEmail   String?  @db.VarChar(255)
  billingAddress Json?
  currency       String   @default("EUR")
  taxStatus      String?  @db.VarChar(32)
  taxExempt      Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  shop           Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([vatNumber])
  @@index([vatCountry])
}

model Subscription {
  id                   String   @id @default(cuid())
  shopId               String   @unique
  provider             String   @default("stripe")
  stripeCustomerId     String?  @db.VarChar(255)
  stripeSubscriptionId String?  @unique @db.VarChar(255)
  planCode             String?  @db.VarChar(50)
  status               String?  @db.VarChar(40)
  currency             String?  @db.VarChar(3)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean  @default(false)
  trialEndsAt          DateTime?
  metadata             Json?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  shop                 Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
}

model InvoiceRecord {
  id                   String   @id @default(cuid())
  shopId               String
  stripeInvoiceId      String   @unique @db.VarChar(255)
  stripeCustomerId     String?  @db.VarChar(255)
  stripeSubscriptionId String?  @db.VarChar(255)
  invoiceNumber        String?  @db.VarChar(64)
  subtotal             Int?
  tax                  Int?
  total                Int?
  currency             String?  @db.VarChar(3)
  pdfUrl               String?  @db.Text
  hostedInvoiceUrl     String?  @db.Text
  status               String?  @db.VarChar(40)
  issuedAt             DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  shop                 Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  taxEvidence          TaxEvidence?

  @@index([shopId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([issuedAt])
}

model TaxEvidence {
  id             String   @id @default(cuid())
  shopId         String
  invoiceId      String?  @unique
  ipCountry      String?  @db.VarChar(2)
  billingCountry String?  @db.VarChar(2)
  vatIdProvided  String?  @db.VarChar(32)
  vatIdValidated Boolean?
  taxRateApplied Float?
  taxJurisdiction String? @db.VarChar(64)
  taxTreatment   String?  @db.VarChar(32)
  createdAt      DateTime @default(now())
  shop           Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  invoice        InvoiceRecord? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  @@index([shopId])
  @@index([billingCountry])
  @@index([taxTreatment])
}

model BillingTransaction {
  id              String   @id @default(cuid())
  shopId          String
  creditsAdded    Int
  amount          Int      // Amount in cents
  currency        String   @default("EUR")
  packageType     String
  stripeSessionId String
  stripePaymentId String?
  idempotencyKey  String?  // P0: Prevent double processing (e.g., stripeEventId)
  status          String   @default("pending") // pending, completed, failed
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  shop            Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([shopId, idempotencyKey])
  @@index([shopId, createdAt])
  @@index([stripeSessionId])
  @@index([stripePaymentId])
}

model CreditTransaction {
  id             String        @id @default(cuid())
  shopId         String
  shop           Shop          @relation(fields: [shopId], references: [id], onDelete: Cascade)
  type           CreditTxnType
  amount         Int // positive integer (credits)
  balanceAfter   Int // snapshot of wallet balance after this txn
  reason         String?       @db.VarChar(200)
  campaignId     String?
  campaign       Campaign?     @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  messageId      String?
  message        MessageLog?   @relation(fields: [messageId], references: [id], onDelete: SetNull)
  idempotencyKey String?       // P0: Prevent double debit
  meta           Json?
  createdAt      DateTime      @default(now())
  walletId       String?
  wallet         Wallet?       @relation(fields: [walletId], references: [id], onDelete: SetNull)

  @@unique([shopId, idempotencyKey])
  @@index([shopId])
  @@index([campaignId])
  @@index([messageId])
  @@index([walletId])
  @@index([createdAt])
  @@index([reason])
  @@index([shopId, reason])
}

model CreditReservation {
  id             String    @id @default(cuid())
  shopId         String
  shop           Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)
  campaignId     String?   // Optional: link to campaign
  campaign       Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  amount         Int       // Credits reserved
  reservationKey String?   // P0: Unique key for idempotency (shopId + campaignId or custom)
  status         String    @default("active") // active, released, expired
  expiresAt      DateTime? // Optional expiration
  releasedAt      DateTime? // When reservation was released
  meta           Json?     // Additional metadata
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([shopId, reservationKey])
  @@index([shopId])
  @@index([campaignId])
  @@index([status])
  @@index([expiresAt])
  @@index([shopId, status])
}

model Template {
  id                   String          @id @default(cuid())
  shopId               String?         // NULL for global/public templates, set for shop-specific templates
  eshopType            EshopType       // eShop vertical/category (aligned with Shopify-specific requirement)
  templateKey          String          // Stable identity for default templates (e.g., "welcome_new_customer")
  title                String          // Legacy field (deprecated, use name)
  name                 String          // Retail-aligned field name
  category             String          // Template category (e.g., "welcome", "promotion", "reminder")
  content              String          // Legacy field (deprecated, use text)
  text                 String          // Retail-aligned field name (SMS content with {{first_name}} placeholders)
  language             String          @default("en") // Language support (en, gr) - aligned with Retail
  goal                 String?         @db.VarChar(200) // Use case description - aligned with Retail
  suggestedMetrics     String?         @db.VarChar(500) // Suggested KPIs to watch - aligned with Retail
  previewImage         String?
  tags                 String[]        @default([])
  isPublic             Boolean         @default(true) // true for global templates (shopId = NULL), can be false for private shop templates
  isSystemDefault      Boolean         @default(false) // Flag for default templates
  // Statistics fields
  conversionRate       Float? // Conversion rate percentage (e.g., 33.5 for 33.5%)
  productViewsIncrease Float? // Product views increase percentage (e.g., 55.0 for 55%)
  clickThroughRate     Float? // Click-through rate percentage
  averageOrderValue    Float? // Average order value increase percentage
  customerRetention    Float? // Customer retention improvement percentage
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt
  shop                 Shop?           @relation(fields: [shopId], references: [id], onDelete: SetNull)
  usage                TemplateUsage[]

  @@unique([shopId, eshopType, templateKey]) // Prevent duplicates per tenant + eShop type + template key (shopId can be NULL)
  @@index([shopId, eshopType]) // For filtering by tenant and eShop type
  @@index([eshopType]) // For filtering by eShop type across tenants (if needed)
  @@index([language]) // For language filtering - aligned with Retail
  @@index([category]) // For category filtering
  @@index([isPublic]) // For filtering global/public templates
}

model QueueJob {
  id          String    @id @default(cuid())
  queueName   String
  jobName     String
  data        String // JSON string
  status      String    @default("pending") // pending, processing, completed, failed
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  priority    Int       @default(0)
  delay       DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  failedAt    DateTime?
  result      String? // JSON string
  error       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([queueName, status])
  @@index([status, createdAt])
  @@index([delay])
}

model ShopifySession {
  id          String    @id
  shop        String
  state       String?
  isOnline    Boolean   @default(false)
  scope       String?
  expires     DateTime?
  accessToken String?
  userId      String?
  sessionData String // JSON string
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([shop])
  @@index([expires])
  @@index([shop, isOnline])
}

model RateLimitRecord {
  id        String   @id @default(cuid())
  key       String
  createdAt DateTime @default(now())

  @@index([key, createdAt])
  @@index([createdAt])
}

model ShortLink {
  id            String    @id @default(cuid())
  token         String    @unique
  destinationUrl String    @db.Text
  shopId        String?
  campaignId    String?
  contactId     String?
  clicks        Int       @default(0)
  createdAt     DateTime  @default(now())
  lastClickedAt DateTime?
  expiresAt     DateTime?
  meta          Json?
  shop          Shop?     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  campaign      Campaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  contact       Contact?  @relation(fields: [contactId], references: [id], onDelete: SetNull)

  @@index([shopId])
  @@index([campaignId])
  @@index([contactId])
  @@index([token])
  @@index([expiresAt])
}

// P0: Webhook replay protection
model WebhookEvent {
  id         String    @id @default(cuid())
  provider   String    // 'shopify', 'stripe', 'mitto'
  eventId    String    // Provider's event ID
  eventHash  String?   // Optional hash for deduplication
  payloadHash String?  // Optional payload hash for audit
  eventType  String?   // Provider event type (e.g., stripe event type)
  shopId     String?   // Optional shop context
  receivedAt DateTime  @default(now())
  processedAt DateTime?
  status     String    @default("received") // received, processed, failed, duplicate
  payload    Json?     // Store full payload for debugging
  error      String?   // Error message if processing failed
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  shop       Shop?     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([provider, eventId])
  @@index([shopId])
  @@index([provider, status])
  @@index([receivedAt])
}

// P0: Endpoint-level idempotency for campaign enqueue
model EnqueueRequest {
  id             String   @id @default(cuid())
  shopId         String
  campaignId     String
  idempotencyKey String   // Header: Idempotency-Key
  status         String   @default("pending") // pending, completed, failed
  result         Json?    // Store response for replay
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  shop           Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@unique([shopId, campaignId, idempotencyKey])
  @@index([campaignId])
  @@index([shopId, createdAt])
}
